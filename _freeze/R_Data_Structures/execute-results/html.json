{
  "hash": "d7a7e01f91c84ebf9501292c5f81cae8",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Structures {.unnumbered}\n\nIn the previous section we discussed storing objects as variables so that they can be easily referenced later:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 54321\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54321\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- \"science\"\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"science\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nR can handle much more than a single object in a variable. You can add thousands of objects to a single variable and they can be of the same or different types and even have multiple rows or columns. The terms used to describe how multiple objects are stored depends on whether the objects are of the same (homogeneous) or different (heterogeneous) types and their dimensions:\n\n| Rows | Homogeneous   | Heterogeneous |\n|:-----|:--------------|:--------------|\n| 1d   | Atomic vector | List          |\n| 2d   | Matrix        | Data frame    |\n| nd   | Array         |               |\n\nIn the simplest case, a group of objects of the same type can be combined (using combine, `c()`) to form an atomic vector:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Combining several numbers (type: double) into a vector stored as an object called \"string\"\n\nstring <- c(1,2,3,4,5)\nstring\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.atomic(string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nHowever, if you try to combine objects of different types using `c()`, R will try to convert them all to the same data type:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- c(1,2,3,4,5,\"six\")\nstring\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"   \"2\"   \"3\"   \"4\"   \"5\"   \"six\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.atomic(string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nTo ensure that the original data type is preserved, you can intentionally create a list:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- list(1,2,3,4,5,\"six\")\ntypeof(string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.atomic(string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
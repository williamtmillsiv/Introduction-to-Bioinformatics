{
  "hash": "a09333edfb90a1e68154065a53d970db",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Structures {.unnumbered}\n\nIn the previous section we discussed storing objects as variables so that they can be easily referenced later:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 54321 # Store the number 54321 as a object called 'x'\nx # View the contents of x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54321\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x) # Check the data type of x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- \"science\" # Store the word \"science\" as a object called 'y'\ny # View the contents of y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"science\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y) # Check the data type of y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nR can handle much more than a single object in a variable. You can add thousands of objects to a single variable and they can be of the same or different types and even have multiple rows or columns. The terms used to describe how multiple objects are stored depends on whether the objects are of the same (homogeneous) or different (heterogeneous) types and their dimensions:\n\n| Rows | Homogeneous   | Heterogeneous |\n|:-----|:--------------|:--------------|\n| 1d   | Atomic vector | List          |\n| 2d   | Matrix        | Data frame    |\n| nd   | Array         |               |\n\nIn the simplest case, a group of objects of the same type can be combined (using combine, `c()`) to form an atomic vector:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- c(1,2,3,4,5) # Create an object called 'string' containing the numbers 1-5\nstring # View the contents of string\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(string) # Check the data type of string\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.atomic(string) # Check if string is an atomic vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nHowever, if you try to combine objects of different types using `c()`, R will force (i.e. coerce) them all to the same data type (in this case, characters):\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- c(1,2,3,4,5,\"six\") # Create an object called 'string' containing the numbers 1-5 and the word \"six\"\nstring # View the contents of string\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"   \"2\"   \"3\"   \"4\"   \"5\"   \"six\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(string) # Check the data type of string\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.atomic(string) # Check if string is an atomic vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nTo ensure that the original data type is preserved, you can instead use a list:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- list(1,2,3,4,5,\"six\") # Create an object called 'string' containing the numbers 1-5 and the word \"six\". stored as a list\ntypeof(string) # Check the data type of string\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.atomic(string) # Check if string is an atomic vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nYou can even confirm that the data type of each element in the list has been preserved (this code uses a process called subsetting, a topic that will be discussed later):\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Determine the data type of the 2nd element in the list\ntypeof(string[[2]]) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Determine the data type of the 6th element in the list\ntypeof(string[[6]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nWhile atomic vectors and lists are one-dimensional data structures, data can also be stored in multiple dimensions. A two-dimensional structure that contains data of the same type is called a matrix. There are multiple ways to create a matrix. One of them is by using a column bind (`cbind()`) or row bind (`rbind()`):\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_A <- cbind(c(1,2,3),c(4,5,6)) # Create a matrix using cbind and store it as an object called 'matrix_A'\nmatrix_A # View the contents of matrix_A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(matrix_A) # Check the data type of matrix_A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.matrix(matrix_A) # Check if matrix_A is a matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_B <- rbind(c(1,2,3),c(4,5,6)) # Create a matrix using rbind and store it as an object called 'matrix_B'\nmatrix_B # View the contents of matrix_B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(matrix_B) # Check the data type of matrix_B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.matrix(matrix_B) # Check if matrix_B is a matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nAs with using c() above to create a vector, R will coerce everything to the same data type:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_C <- rbind(c(1,2,\"three\"),c(4,5,6)) # Create a matrix using rbind and store it as an object called 'matrix_C'\nmatrix_C # View the contents of matrix_C\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]   \n[1,] \"1\"  \"2\"  \"three\"\n[2,] \"4\"  \"5\"  \"6\"    \n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(matrix_C) # Check the data type of matrix_C\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nEven if you try to make one row of the matrix a list to preserve the different data types, R will coerce every row of the matrix to a list so that it is technically still the same data type throughout:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_C <- rbind(list(1,2,\"three\"),c(4,5,6)) # Create a matrix using rbind and store it as an object called 'matrix_C'\nmatrix_C # View the contents of matrix_C\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]   \n[1,] 1    2    \"three\"\n[2,] 4    5    6      \n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(matrix_C) # Check the data type of matrix_C\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.matrix(matrix_C) # Check if matrix_C is a matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(matrix_C[2,]) # Check the type of data stored in row 2 of matrix_C\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nSo while this technically does allow the matrix to hold different data types, storing them within lists prevents certain matrix operations from being able to be used on the matrix.\n\nTo preserve different data types in a two-dimensional structure without needing to store them as lists, you can instead use a data frame. This will allow atomic vectors of different types to be combined as columns within a single structure:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndataframe_A <- data.frame(c(1,2,3),c(\"four\", \"five\", \"six\")) # Create a data frame and store it as an object called dataframe_A\ndataframe_A # View dataframe_A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  c.1..2..3. c..four....five....six..\n1          1                     four\n2          2                     five\n3          3                      six\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(dataframe_A[,1]) # Check type of data in column 1 of dataframe_A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(dataframe_A[,2]) # Check type of data in column 2 of dataframe_A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.data.frame(dataframe_A) # Check if dataframe_A is a data frame?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nFinally, a data structure with two or more dimensions is called an array. Arrays are similar to matrices in that they can only store one data type (unless you store the data as lists as described above for matrices, which limits which array functions can be used):\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narray_A <- array(1:12, dim = c(2, 3, 2)) # Create an array using the numbers 1-12 stored in 2 rows, 3 columns, and 2 \"layers\" (i.e. the third dimension) and store it as an object called array_A\narray_A # View the contents of array_A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe most common data structure used in bioinformatics is a data frame, though you may also use matrices for simpler datasets. Knowing how each data structure is composed and what data type(s) can be stored within them will be very useful when trying to perform operations on these structures (as will be discussed later).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
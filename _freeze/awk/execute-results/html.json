{
  "hash": "8aeab18281c5c28e3cbb85cd5dc32e6d",
  "result": {
    "engine": "jupyter",
    "markdown": "# awk {.unnumbered}\n\n------------------------------------------------------------------------\n\nawk is scripting language named after its developers (Aho, Weinberger, and Kernighan) ([usage](https://www.geeksforgeeks.org/awk-command-unixlinux-examples/))\n\n------------------------------------------------------------------------\n\nThings to know about awk:\n\n-   awk refers to columns as field, such as in the variables for number of fields (`NF`), input field separator (`FS`), and output field separator (`OFS`).\n\n-   awk refers to rows as records, such as in the variables for record number (`NR`), input record separator (`RS`), and output record separator (`ORS`).\n\n-   By default, awk recognizes a space or tab as a field separator. If your input file has field separators other than a space or a tab, you need to specify it using the `-F` flag.\n\n-   awk has several built-in variables that can be used when writing code:\n\n    -   `$1` = field 1 (\\$2 = field 2, \\$3 = field 3, ...)\n\n    -   `$0` = entire record\n\n    -   `NF` = number of fields\n\n    -   `NR` = number of records\n\n    -   `FS` = input field separator; default is white space (i.e. space and tab)\n\n    -   `OFS` = output field separator; default is single space\n\n    -   `RS` = input record separator; default is new line\n\n    -   `ORS` = output record separator; default is new line\n\n    -   `[0-9]` = any number\n\n------------------------------------------------------------------------\n\nEach of the code examples shown below is preceded by viewing the input file to better visualize what each line of code is doing. The `$` at the beginning of each line of code represents the end of prompt you see in your command line. If you'd like to run the code in these examples, simply copy everything after the `$` into your command line.\n\nThis is test code\n\n\n\n\n\n\n\n```{bash}\n# Test bash code\n```\n\n\n\n\n\n\n\n\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n```\n\nPrinting all of the fields (synonymous with `awk '{print $0}' data.txt`)\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk '{print}' data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n```\n\nPrint a particular field (e.g. field 1)\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk '{print $1}' data.txt\nGeneNames\nGeneX\nGeneY\nGeneZ\n```\n\nSet input field separator as comma (,) (synonymous with `awk '{ FS = \",\" } ; {print $1}' data.csv`). Try leaving out the `-F,` and see what happens.\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data.csv\nGeneNames,Sample1,Sample2,Sample3\nGeneX,321,5678,689\nGeneY,2354,6700,987\nGeneZ,2315,7890,123\n$ awk -F, '{print $1}' data.txt\nGeneNames\nGeneX\nGeneY\nGeneZ\n```\n\nPrint multiple fields (e.g. field 1 and 3)\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk '{print $1,$3}' data.txt\nGeneNames Sample2\nGeneX 5678\nGeneY 6700\nGeneZ 7890\n```\n\nPrint the last field\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk '{print $NF}' data.txt\nSample3\n689\n987\n123\n```\n\nPrint all records after the first record (synonymous with `awk 'NR!=1 {print}' /path/to/file`)\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk 'NR>1 {print}' data.txt\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n```\n\nPrint a particular record (e.g. record 3)\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk 'NR==3 {print}' data.txt\nGeneY 2354  6700  987\n```\n\nPrint all records except for a particular record (e.g. not record 3)\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk 'NR!=3 {print}' data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneZ 2315  7890  123\n```\n\nPrint a range of records (e.g. records 2 to 3)\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk 'NR==2, NR==3 {print}' data.txt\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n```\n\nPrint records with fewer than a certain number of fields (e.g. fewer than 4 fields)\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data2.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700\nGeneZ 2315  7890  123\n$ awk 'NF<4 {print}' data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneZ 2315  7890  123\n```\n\nPrint records containing a certain string anywhere in record (e.g. `abc`):\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data3.txt\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n$ awk '/abc/ {print}'\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\n```\n\nPrint records starting with a certain string\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data3.txt\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n$ awk '/^abc/ {print}'\nabcd dcba efgh  hgfe\n```\n\nPrint records ending with a certain string. One caveat between macOS and Windows (even when using wsl) is that the line ending character in macOS (i.e. unix) is `\\n` while the line ending character in Windows is `\\r\\n`. This means that a text file made on a Mac may have a different line ending character than Windows recognizes (and vice versa). To avoid this problem...\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data3.txt\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n$ awk '/abc$/ {print}'\nabcd dcba efgh  hgfe\n```\n\nPrint records that don't contain a certain string anywhere in record\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data3.txt\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n$ awk '!/abc/ {print}'\ncdef defg  efgh  fghi\n```\n\n-   Print records that don't start with a certain string: `awk '!/^string/ {print}' /path/to/file`\n\n``` {style=\"background-color: whitesmoke\"}\n$ cat data3.txt\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n$ awk '!/^abc/ {print}'\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n```\n\n\n-   Print records that don't end with a certain string: `awk '!/string$/ {print}' /path/to/file`\n\n-   Print records where a particular field contains a string (e.g. field 1): `awk '$1 ~ /string/ {print}' /path/to/file`\n\n-   Print records where a particular field starts with a string (e.g. field 1): `awk '$1 ~ /^string/ {print}' /path/to/file`\n\n-   Print records where a particular field ends with a string (e.g. field 1): `awk '$1 ~ /string$/ {print}' /path/to/file`\n\n-   Print records where a particular field starts with any number (e.g. field 1): `awk '$1 ~ /^[0-9]/ {print}' /path/to/file`\n\n-   Print records where a particular field ends with any number (e.g. field 1): `awk '$1 ~ /[0-9]$/ {print}' /path/to/file`\n\n-   Ignore case when looking for records containing a string: `awk 'tolower($0) ~ /string/ {print}' /path/to/file`\n\n-   Print records that contain a certain value in a particular field (e.g. the number 10 in field 2): `awk '$2==10 {print}' /path/to/file`\n\n-   Print records that do not contain a certain value in a particular field (e.g. not the number 10 in field 2): `awk '$2!=10 {print}' /path/to/file`\n\n-   Print records that contain a value greater than a certain value in a particular field (e.g. \\>10 in field 2): `awk '$2>10 {print}' /path/to/file`\n\n-   Print records that contain a value less than a certain value in a particular field (e.g. \\<10 in field 2): `awk '$2<10 {print}' /path/to/file`\n\nSum values in a field (e.g. field 2): `awk '{sum+=$2;} END{print sum;}' /path/to/file`\n\n-   Remember to add `NR>1` if your file has a header: `awk 'NR>1 {sum+=$2;} END{print sum;}' /path/to/file`\n\nRemove blank lines: `awk 'NF' /path/to/file`Â \n\nPrint the record number at beginning of record: `awk '{print NR,$0}' /path/to/file`\n\n",
    "supporting": [
      "awk_files"
    ],
    "filters": [],
    "includes": {}
  }
}
[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Bioinformatics",
    "section": "",
    "text": "Introduction\nThis book will explore what types of biological data are out there, what tools are available to process them, and how you can begin processing data on your own computer. Even though the main emphasis of this book will be helping readers understand how to process sequencing data, many of the ideas and skills learned will be useful for dealing with other forms of biological data.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Introduction to Bioinformatics",
    "section": "Prerequisites",
    "text": "Prerequisites\nWhile this book is intended for readers with no computational experience, a general understanding of molecular biology (such as would be learned in an introductory biology course) would be useful for understanding the types of data being processed and the analyses being performed. When possible, references will be included to direct readers to additional resources for understanding biological concepts.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#structure-of-the-book",
    "href": "index.html#structure-of-the-book",
    "title": "Introduction to Bioinformatics",
    "section": "Structure of the Book",
    "text": "Structure of the Book\nThis book is broken up into ___ main sections:\n\nSection 1\nSection 2\nSection 3\nSection 4\nSection 5\n\nEach section contains several chapters that dive into the concepts that comprise that section. Each chapter will include references to additional resources that readers may pursue for more advanced information about the topic being discussed. Additionally, exercises will be included in each chapter to help readers put newly learned skills to the test and see real-world applications for the topics being learned.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Introduction to Bioinformatics",
    "section": "License",
    "text": "License\n\n\n\n\n\nThis work is free to use, and is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Introduction to Bioinformatics",
    "section": "About Me",
    "text": "About Me\n\n\nI earned my B.S. in Biochemistry from the University of Virginia (Charlottesville, VA) in 2017 and my Ph.D. in Biological Chemistry from the Johns Hopkins University School of Medicine (Baltimore, MD) in 2023. I am now an Assistant Professor of Biology at Mount St. Mary’s University (Emmitsburg, MD). I began working in bioinformatics during graduate school where I developed pipelines for processing novel types of sequencing data. While my formal training was in chemistry and biology, my experience in bioinformatics was largely self taught. I now strive to share what I’ve learned with scientists looking to step into bioinformatics for the first time.\n\n\n \n\n\nPlease contribute to this book by submitting your feedback: https://github.com/williamtmills/Introduction-to-Bioinformatics\nThis is a Quarto book. To learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "p0c1-what-is-bioinformatics.html#common-terms-to-understand",
    "href": "p0c1-what-is-bioinformatics.html#common-terms-to-understand",
    "title": "1  What is Bioinformatics?",
    "section": "",
    "text": "code: a group of text, when executed, that performs a computational task\ndirectory: a place where files are stored; synonymous with “folder”\nexecute:\n(a) to run a line of code or script\n(b) in reference to privileges, the ability to run a script\nread:\n(a) a single sequence letters corresponding to nucleotide bases of DNA or RNA\n(b) in references to privileges, the ability to open and view a file or directory\nscript: a file that contains multiple lines of code that collectively perform a computational task\nwrite: in references to privileges, to add to a file or directory",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>What is Bioinformatics?</span>"
    ]
  },
  {
    "objectID": "p0c2-ethical-considerations.html#the-story-of-henrietta-lacks",
    "href": "p0c2-ethical-considerations.html#the-story-of-henrietta-lacks",
    "title": "2  Ethical Considerations",
    "section": "",
    "text": "Skloot, Rebecca. 2011. The Immortal Life of Henrietta Lacks. 1st pbk. Broadway Books.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ethical Considerations</span>"
    ]
  },
  {
    "objectID": "p0c3-historical-perspective.html#doing-bioinformatics-well",
    "href": "p0c3-historical-perspective.html#doing-bioinformatics-well",
    "title": "3  Historical Perspective",
    "section": "",
    "text": "Stay organized. While you may have experience making documents and folders on your computer, doing bioinformatics requires taking this practice to the next level. You should maintain a very organized file structure that allows you to easily retrieve files and understand how they were generated. This could involve having folders (often called “directories” in bioinformatics) inside of folders and README files that explain when how the files in that folder were generated. You need to properly label folders and files with version IDs more easily understand when the files were generated and using which protocols.\nTake good notes. When you begin writing code and eventually entire scripts, you will find it easier to keep writing code than annotating your script. Resist this urge. Just as you would take notes in your lab notebook during the course of an experiment at the bench, you should always take notes on what you are trying to accomplish, what difficulties or errors you experience along the way, and how you solved the problems and reached your final conclusion. Taking good notes will save you countless hours of having to go back and understand what a particular line of code is doing or trying to solve a previously-solved issue.\nOutput run info.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Historical Perspective</span>"
    ]
  },
  {
    "objectID": "p0c1-what-is-bioinformatics.html",
    "href": "p0c1-what-is-bioinformatics.html",
    "title": "1  What is Bioinformatics?",
    "section": "",
    "text": "1.1 Common terms to understand\nIn this book, and throughout your time engaged with bioinformatics, you will encounter many terms that may not be in your everyday lexicon but will become invaluable to successful computing. While some terms may describe new ideas to you, others may be synonyms for terms you are more familiar with but are necessary to use when dealing with computers. Though not an exhaustive list, below are several of the terms you may encounter in bioinformatics:",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>What is Bioinformatics?</span>"
    ]
  },
  {
    "objectID": "p0c2-ethical-considerations.html",
    "href": "p0c2-ethical-considerations.html",
    "title": "2  Ethical Considerations",
    "section": "",
    "text": "2.1 The Story of Henrietta Lacks\nThe event that is most often used to highlight importance of bioethics, specifically relating to human patients, is the story of Henrietta Lacks (Skloot 2011).",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ethical Considerations</span>"
    ]
  },
  {
    "objectID": "p0c3-historical-perspective.html",
    "href": "p0c3-historical-perspective.html",
    "title": "3  Historical Perspective",
    "section": "",
    "text": "3.1 Doing bioinformatics well\nOver the course of your scientific career using bioinformatics, you will write thousands of lines of codes and generate possible hundreds of different scripts. When compared to canonical experiments where researchers are able to complete one experiment every few days, bioinformatics “experiments” can be executed in minutes, meaning you can complete dozens or even hundreds of experiments in a week. This necessitates a very high degree of organization and note taking to keep track of all your protocols, data, and analyses. Before we even write our first line of code, there are a few tips that can help us start on the right foot:",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Historical Perspective</span>"
    ]
  },
  {
    "objectID": "getting_started.html",
    "href": "getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "Windows (using Windows Subsystem for Linux (WSL))",
    "crumbs": [
      "Command Line",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting_started.html#windows-using-windows-subsystem-for-linux-wsl",
    "href": "getting_started.html#windows-using-windows-subsystem-for-linux-wsl",
    "title": "Getting Started",
    "section": "",
    "text": "Open the Windows Terminal application\nRun (i.e. type in) wsl --install (and click enter)\nRestart your device\nOpen Windows Terminal\nRun wsl\nBy default this should open the distribution (Ubuntu by default)\n\n\nIf this doesn’t work, you may need to run wsl.exe --install -d Ubuntu and may need to restart your computer again\nEnter a username and password (does not need to match your computer login)\n\nYou won’t see what you type in appear on the screen, just hit enter when you are done\n\nTo log out of the distribution, run exit\nEvery time you open Windows Terminal, you need to run wsl to turn on Windows Subsystem for Linux",
    "crumbs": [
      "Command Line",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting_started.html#mac-using-terminal",
    "href": "getting_started.html#mac-using-terminal",
    "title": "Getting Started",
    "section": "Mac (using Terminal)",
    "text": "Mac (using Terminal)\n\nOpen Terminal (Applications &gt; Utilities &gt; Terminal)",
    "crumbs": [
      "Command Line",
      "Getting Started"
    ]
  },
  {
    "objectID": "terminology.html",
    "href": "terminology.html",
    "title": "Terminology",
    "section": "",
    "text": "As with any field, there are certain words in phrases used by people in those fields that may not be familiar to others. The same is true with bioinformatics. Below are a few common terms used in bioinformatics that you should become familiar with as you will encounter them frequently.\ncommand line: a text-based interface where you can interact with the operating system (using a shell)\nIn English: an app that lets you type instructions for controlling the computer\nDefault command line interfaces on various operating systems:\nWindows: Windows Terminal\nmacOS: Terminal\nLinux: (usually) Terminal\nshell: a computer program that allows users to interact with the operating system rather than using a graphical user interface (GUI)\nIn English: a way of interacting with your computer without pointing and clicking with a mouse\nWhy is this helpful? What if you wanted to change the name of 10 files on your computer? If you used your mouse to find the files on your computer and then change their names one by one, this could take several minutes. However, using a shell and the command line, you can perform this task in less than a second with the right instructions (i.e. code).\nDefault shells on various operating systems:\nWindows: Powershell\nmacOS: Z shell (zsh)\nLinux: (usually) Bourne-again shell (bash)",
    "crumbs": [
      "Command Line",
      "Terminology"
    ]
  },
  {
    "objectID": "terminology.html#windows-using-windows-subsystem-for-linux-wsl",
    "href": "terminology.html#windows-using-windows-subsystem-for-linux-wsl",
    "title": "6  Terminology",
    "section": "",
    "text": "Open the Windows Terminal application\nRun (i.e. type in) wsl --install (and click enter)\nRestart your device\nOpen Windows Terminal\nRun wsl\nBy default this should open the distribution (Ubuntu by default)\n\n\nIf this doesn’t work, you may need to run wsl.exe --install -d Ubuntu and may need to restart your computer again\nEnter a username and password (does not need to match your computer login)\n\nYou won’t see what you type in appear on the screen, just hit enter when you are done\n\nTo log out of the distribution, run exit\nEvery time you open Windows Terminal, you need to run wsl to turn on Windows Subsystem for Linux",
    "crumbs": [
      "Command Line",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Terminology</span>"
    ]
  },
  {
    "objectID": "terminology.html#mac-using-terminal",
    "href": "terminology.html#mac-using-terminal",
    "title": "6  Terminology",
    "section": "6.2 Mac (using Terminal)",
    "text": "6.2 Mac (using Terminal)\n\nOpen Terminal (Applications &gt; Utilities &gt; Terminal)",
    "crumbs": [
      "Command Line",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Terminology</span>"
    ]
  },
  {
    "objectID": "command_line.html",
    "href": "command_line.html",
    "title": "Command Line",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Command Line"
    ]
  },
  {
    "objectID": "Command_Line_Tips.html",
    "href": "Command_Line_Tips.html",
    "title": "Command Line Tips",
    "section": "",
    "text": "Press ‘tab’ button to autofill\nDepending on shell, hitting tab once (zsh) or twice (bash) will display options if multiple exist\nPress ‘up’ arrow to recall last command\n‘Control + A’ to move to beginning of line\n‘Control + E’ to move to end of line\n‘Control + C’ to end (i.e. kill) command\n‘Control + Z’ to exit manual\nAvoid using spaces when naming files or folders\nBeware curly (i.e. smart) quotes ‘, be sure to use straight quotes '. Curly quotes usually come from text editors like Microsoft Word and don’t work when coding. To ensure you are using straight quotes, write code in a plain-text editor like TextEdit (Mac) or Notepad (Windows) and turn off spelling and grammar checking.",
    "crumbs": [
      "Command Line",
      "Command Line Tips"
    ]
  },
  {
    "objectID": "Scripting_Tips.html",
    "href": "Scripting_Tips.html",
    "title": "Scripting Tips",
    "section": "",
    "text": "When using a bash shell, start every script with #!/bin/bash\nWrite scripts with a plain-text editor such as TextEdit (Mac) or Notepad (Windows)\nTurn off spelling and grammar checking:\n\nIn TextEdit (Mac): Edit &gt; Spelling and Grammar &gt; Uncheck ‘Check Spelling While Typing’ and ‘Correct Spelling Automatically’\nIn Notepad (Windows): Select Setting (top right) &gt; Scroll down to Spelling section &gt; Toggle off ‘Autocorrect’ and ‘Spell Check’\n\nThoroughly annotate scripts (adding a # at the beginning of a line causes it to be ignored when the computer reads the script).",
    "crumbs": [
      "Command Line",
      "Scripting Tips"
    ]
  },
  {
    "objectID": "Built-In_Commands.html",
    "href": "Built-In_Commands.html",
    "title": "Built-In Command Line Tools",
    "section": "",
    "text": "Your terminal will have several commands already built into the command line. Below are a few of them with examples of how they are used.\npwd: print working directory (where am I currently?)\n \n/: root directory (folder that holds all other folders)\n./: current directory (current folder)\n../: parent directory (folder containing your current folder)\n \nls: list directory contents (list everything in current folder) (usage)\n\nFlags:\n\n-l: long format (permissions, sizes, dates, etc.)\n-F: indicate item types\n\ntrailing / = directory\n@ = link\n* = executable\n\n-r: reverse order (reverse alphabetic order)\n\n\n \nmkdir: make directory (i.e. folder) (usage)\n \nmv: move object (usage)\n\nmv [source(s)] [destination]\n*Warning* Will overwrite object if name already exists\nWhen in the same folder: renames object\nFlags:\n\n-i: interactive (ask for confirmation before overwriting)\n\n\n \ncp: copy object (usage)\n\ncp [source object(s)] [destination]\n*Warning* Will overwrite object if name already exists\nFlags:\n\n-R: copy directory (i.e. folder)\n-i: interactive (ask for confirmation before overwriting)\n\n\n \nhead: display the beginning (i.e. top) of a file (usage)\n\nFlags:\n\n-1: display first row\n-3: display first 3 rows\n\n\n \ntail: display the end (i.e. bottom) of a file (usage)\n\nFlags:\n\n-1: display last row\n-3: display last 3 rows\n\n\n \n| (shift + backslash): pipe (use outputs from one command as inputs for another)\n\nExample: display the 10th row of a file\n\nhead -10 path/to/file | tail -1\n\n\n \nwc: word count (lines, words, characters) (usage)\n\nFlags:\n\n-l: lines\n-w: words\n-c: characters",
    "crumbs": [
      "Command Line",
      "Built-In Command Line Tools"
    ]
  },
  {
    "objectID": "awk.html",
    "href": "awk.html",
    "title": "awk",
    "section": "",
    "text": "awk is scripting language named after its developers (Aho, Weinberger, and Kernighan) (usage)\n\nThings to know about awk:\n\nawk refers to columns as field, such as in the variables for number of fields (NF), input field separator (FS), and output field separator (OFS).\nawk refers to rows as records, such as in the variables for record number (NR), input record separator (RS), and output record separator (ORS).\nBy default, awk recognizes a space or tab as a field separator. If your input file has field separators other than a space or a tab, you need to specify it using the -F flag.\nawk has several built-in variables that can be used when writing code:\n\n$1 = field 1 ($2 = field 2, $3 = field 3, …)\n$0 = entire record\nNF = number of fields\nNR = number of records\nFS = input field separator; default is white space (i.e. space and tab)\nOFS = output field separator; default is single space\nRS = input record separator; default is new line\nORS = output record separator; default is new line\n[0-9] = any number\n\n\n\nEach of the code examples shown below is preceded by viewing the input file to better visualize what each line of code is doing. The $ at the beginning of each line of code represents the end of prompt you see in your command line. If you’d like to run the code in these examples, simply copy everything after the $ into your command line.\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\nPrinting all of the fields (synonymous with awk '{print $0}' data.txt)\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk '{print}' data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\nPrint a particular field (e.g. field 1)\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk '{print $1}' data.txt\nGeneNames\nGeneX\nGeneY\nGeneZ\nSet input field separator as comma (,) (synonymous with awk '{ FS = \",\" } ; {print $1}' data.csv). Try leaving out the -F, and see what happens.\n$ cat data.csv\nGeneNames,Sample1,Sample2,Sample3\nGeneX,321,5678,689\nGeneY,2354,6700,987\nGeneZ,2315,7890,123\n$ awk -F, '{print $1}' data.txt\nGeneNames\nGeneX\nGeneY\nGeneZ\nPrint multiple fields (e.g. field 1 and 3)\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk '{print $1,$3}' data.txt\nGeneNames Sample2\nGeneX 5678\nGeneY 6700\nGeneZ 7890\nPrint the last field\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk '{print $NF}' data.txt\nSample3\n689\n987\n123\nPrint all records after the first record (synonymous with awk 'NR!=1 {print}' /path/to/file)\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk 'NR&gt;1 {print}' data.txt\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\nPrint a particular record (e.g. record 3)\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk 'NR==3 {print}' data.txt\nGeneY 2354  6700  987\nPrint all records except for a particular record (e.g. not record 3)\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk 'NR!=3 {print}' data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneZ 2315  7890  123\nPrint a range of records (e.g. records 2 to 3)\n$ cat data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\n$ awk 'NR==2, NR==3 {print}' data.txt\nGeneY 2354  6700  987\nGeneZ 2315  7890  123\nPrint records with fewer than a certain number of fields (e.g. fewer than 4 fields)\n$ cat data2.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneY 2354  6700\nGeneZ 2315  7890  123\n$ awk 'NF&lt;4 {print}' data.txt\nGeneNames Sample1 Sample2 Sample3\nGeneX 321 5678  689\nGeneZ 2315  7890  123\nPrint records containing a certain string anywhere in record (e.g. abc):\n$ cat data3.txt\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n$ awk '/abc/ {print}'\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\nPrint records starting with a certain string\n$ cat data3.txt\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n$ awk '/^abc/ {print}'\nabcd dcba efgh  hgfe\nPrint records ending with a certain string. One caveat between macOS and Windows (even when using wsl) is that the line ending character in macOS (i.e. unix) is \\n while the line ending character in Windows is \\r\\n. This means that a text file made on a Mac may have a different line ending character than Windows recognizes (and vice versa). To avoid this problem…\n$ cat data3.txt\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n$ awk '/abc$/ {print}'\nabcd dcba efgh  hgfe\nPrint records that don’t contain a certain string anywhere in record\n$ cat data3.txt\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n$ awk '!/abc/ {print}'\ncdef defg  efgh  fghi\n\nPrint records that don’t start with a certain string: awk '!/^string/ {print}' /path/to/file\n\n$ cat data3.txt\nabcd dcba efgh  hgfe\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n$ awk '!/^abc/ {print}'\nbcde dabc  cbad  abdc\ncdef defg  efgh  fghi\n\nPrint records that don’t end with a certain string: awk '!/string$/ {print}' /path/to/file\nPrint records where a particular field contains a string (e.g. field 1): awk '$1 ~ /string/ {print}' /path/to/file\nPrint records where a particular field starts with a string (e.g. field 1): awk '$1 ~ /^string/ {print}' /path/to/file\nPrint records where a particular field ends with a string (e.g. field 1): awk '$1 ~ /string$/ {print}' /path/to/file\nPrint records where a particular field starts with any number (e.g. field 1): awk '$1 ~ /^[0-9]/ {print}' /path/to/file\nPrint records where a particular field ends with any number (e.g. field 1): awk '$1 ~ /[0-9]$/ {print}' /path/to/file\nIgnore case when looking for records containing a string: awk 'tolower($0) ~ /string/ {print}' /path/to/file\nPrint records that contain a certain value in a particular field (e.g. the number 10 in field 2): awk '$2==10 {print}' /path/to/file\nPrint records that do not contain a certain value in a particular field (e.g. not the number 10 in field 2): awk '$2!=10 {print}' /path/to/file\nPrint records that contain a value greater than a certain value in a particular field (e.g. &gt;10 in field 2): awk '$2&gt;10 {print}' /path/to/file\nPrint records that contain a value less than a certain value in a particular field (e.g. &lt;10 in field 2): awk '$2&lt;10 {print}' /path/to/file\n\nSum values in a field (e.g. field 2): awk '{sum+=$2;} END{print sum;}' /path/to/file\n\nRemember to add NR&gt;1 if your file has a header: awk 'NR&gt;1 {sum+=$2;} END{print sum;}' /path/to/file\n\nRemove blank lines: awk 'NF' /path/to/file \nPrint the record number at beginning of record: awk '{print NR,$0}' /path/to/file",
    "crumbs": [
      "Command Line",
      "awk"
    ]
  }
]
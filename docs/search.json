[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Bioinformatics",
    "section": "",
    "text": "Introduction\nThis book will explore what types of biological data are out there, what tools are available to process them, and how you can begin processing data on your own computer. Even though the main emphasis of this book will be helping readers understand how to process sequencing data, many of the ideas and skills learned will be useful for dealing with other forms of biological data.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Introduction to Bioinformatics",
    "section": "Prerequisites",
    "text": "Prerequisites\nWhile this book is intended for readers with no computational experience, a general understanding of molecular biology (such as would be learned in an introductory biology course) would be useful for understanding the types of data being processed and the analyses being performed. When possible, references will be included to direct readers to additional resources for understanding biological concepts.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#structure-of-the-book",
    "href": "index.html#structure-of-the-book",
    "title": "Introduction to Bioinformatics",
    "section": "Structure of the Book",
    "text": "Structure of the Book\nThis book is broken up into ___ main sections:\n\nSection 1\nSection 2\nSection 3\nSection 4\nSection 5\n\nEach section contains several chapters that dive into the concepts that comprise that section. Each chapter will include references to additional resources that readers may pursue for more advanced information about the topic being discussed. Additionally, exercises will be included in each chapter to help readers put newly learned skills to the test and see real-world applications for the topics being learned.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Introduction to Bioinformatics",
    "section": "License",
    "text": "License\n\n\n\n\n\nThis work is free to use, and is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Introduction to Bioinformatics",
    "section": "About Me",
    "text": "About Me\n\n\nI earned my B.S. in Biochemistry from the University of Virginia (Charlottesville, VA) in 2017 and my Ph.D. in Biological Chemistry from the Johns Hopkins University School of Medicine (Baltimore, MD) in 2023. I am now an Assistant Professor of Biology at Mount St. Mary’s University (Emmitsburg, MD). I began working in bioinformatics during graduate school where I developed pipelines for processing novel types of sequencing data. While my formal training was in chemistry and biology, my experience in bioinformatics was largely self taught. I now strive to share what I’ve learned with scientists looking to step into bioinformatics for the first time.\n\n\n \n\n\nPlease contribute to this book by submitting your feedback: https://github.com/williamtmills/Introduction-to-Bioinformatics\nThis is a Quarto book. To learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "p0c1-what-is-bioinformatics.html#common-terms-to-understand",
    "href": "p0c1-what-is-bioinformatics.html#common-terms-to-understand",
    "title": "1  What is Bioinformatics?",
    "section": "",
    "text": "code: a group of text, when executed, that performs a computational task\ndirectory: a place where files are stored; synonymous with “folder”\nexecute:\n(a) to run a line of code or script\n(b) in reference to privileges, the ability to run a script\nread:\n(a) a single sequence letters corresponding to nucleotide bases of DNA or RNA\n(b) in references to privileges, the ability to open and view a file or directory\nscript: a file that contains multiple lines of code that collectively perform a computational task\nwrite: in references to privileges, to add to a file or directory",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>What is Bioinformatics?</span>"
    ]
  },
  {
    "objectID": "p0c2-ethical-considerations.html#the-story-of-henrietta-lacks",
    "href": "p0c2-ethical-considerations.html#the-story-of-henrietta-lacks",
    "title": "2  Ethical Considerations",
    "section": "",
    "text": "Skloot, Rebecca. 2011. The Immortal Life of Henrietta Lacks. 1st pbk. Broadway Books.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ethical Considerations</span>"
    ]
  },
  {
    "objectID": "p0c3-historical-perspective.html#doing-bioinformatics-well",
    "href": "p0c3-historical-perspective.html#doing-bioinformatics-well",
    "title": "3  Historical Perspective",
    "section": "",
    "text": "Stay organized. While you may have experience making documents and folders on your computer, doing bioinformatics requires taking this practice to the next level. You should maintain a very organized file structure that allows you to easily retrieve files and understand how they were generated. This could involve having folders (often called “directories” in bioinformatics) inside of folders and README files that explain when how the files in that folder were generated. You need to properly label folders and files with version IDs more easily understand when the files were generated and using which protocols.\nTake good notes. When you begin writing code and eventually entire scripts, you will find it easier to keep writing code than annotating your script. Resist this urge. Just as you would take notes in your lab notebook during the course of an experiment at the bench, you should always take notes on what you are trying to accomplish, what difficulties or errors you experience along the way, and how you solved the problems and reached your final conclusion. Taking good notes will save you countless hours of having to go back and understand what a particular line of code is doing or trying to solve a previously-solved issue.\nOutput run info.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Historical Perspective</span>"
    ]
  },
  {
    "objectID": "p0c1-what-is-bioinformatics.html",
    "href": "p0c1-what-is-bioinformatics.html",
    "title": "1  What is Bioinformatics?",
    "section": "",
    "text": "1.1 Common terms to understand\nIn this book, and throughout your time engaged with bioinformatics, you will encounter many terms that may not be in your everyday lexicon but will become invaluable to successful computing. While some terms may describe new ideas to you, others may be synonyms for terms you are more familiar with but are necessary to use when dealing with computers. Though not an exhaustive list, below are several of the terms you may encounter in bioinformatics:",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>What is Bioinformatics?</span>"
    ]
  },
  {
    "objectID": "p0c2-ethical-considerations.html",
    "href": "p0c2-ethical-considerations.html",
    "title": "2  Ethical Considerations",
    "section": "",
    "text": "2.1 The Story of Henrietta Lacks\nThe event that is most often used to highlight importance of bioethics, specifically relating to human patients, is the story of Henrietta Lacks (Skloot 2011).",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ethical Considerations</span>"
    ]
  },
  {
    "objectID": "p0c3-historical-perspective.html",
    "href": "p0c3-historical-perspective.html",
    "title": "3  Historical Perspective",
    "section": "",
    "text": "3.1 Doing bioinformatics well\nOver the course of your scientific career using bioinformatics, you will write thousands of lines of codes and generate possible hundreds of different scripts. When compared to canonical experiments where researchers are able to complete one experiment every few days, bioinformatics “experiments” can be executed in minutes, meaning you can complete dozens or even hundreds of experiments in a week. This necessitates a very high degree of organization and note taking to keep track of all your protocols, data, and analyses. Before we even write our first line of code, there are a few tips that can help us start on the right foot:",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Historical Perspective</span>"
    ]
  },
  {
    "objectID": "getting_started.html",
    "href": "getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "Windows (using Windows Subsystem for Linux (WSL))",
    "crumbs": [
      "Command Line",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting_started.html#windows-using-windows-subsystem-for-linux-wsl",
    "href": "getting_started.html#windows-using-windows-subsystem-for-linux-wsl",
    "title": "Getting Started",
    "section": "",
    "text": "Open the Windows Terminal application\nRun (i.e. type in) wsl --install (and click enter)\nRestart your device\nOpen Windows Terminal\nRun wsl\nBy default this should open the distribution (Ubuntu by default)\n\n\nIf this doesn’t work, you may need to run wsl.exe --install -d Ubuntu and may need to restart your computer again\nEnter a username and password (does not need to match your computer login)\n\nYou won’t see what you type in appear on the screen, just hit enter when you are done\n\nTo log out of the distribution, run exit\nEvery time you open Windows Terminal, you need to run wsl to turn on Windows Subsystem for Linux",
    "crumbs": [
      "Command Line",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting_started.html#mac-using-terminal",
    "href": "getting_started.html#mac-using-terminal",
    "title": "Getting Started",
    "section": "Mac (using Terminal)",
    "text": "Mac (using Terminal)\n\nOpen Terminal (Applications &gt; Utilities &gt; Terminal)",
    "crumbs": [
      "Command Line",
      "Getting Started"
    ]
  },
  {
    "objectID": "terminology.html",
    "href": "terminology.html",
    "title": "Terminology",
    "section": "",
    "text": "As with any field, there are certain words in phrases used by people in those fields that may not be familiar to others. The same is true with bioinformatics. Below are a few common terms used in bioinformatics that you should become familiar with as you will encounter them frequently.\ncommand line: a text-based interface where you can interact with the operating system (using a shell)\nIn English: an app that lets you type instructions for controlling the computer\nDefault command line interfaces on various operating systems:\nWindows: Windows Terminal\nmacOS: Terminal\nLinux: (usually) Terminal\nshell: a computer program that allows users to interact with the operating system rather than using a graphical user interface (GUI)\nIn English: a way of interacting with your computer without pointing and clicking with a mouse\nWhy is this helpful? What if you wanted to change the name of 10 files on your computer? If you used your mouse to find the files on your computer and then change their names one by one, this could take several minutes. However, using a shell and the command line, you can perform this task in less than a second with the right instructions (i.e. code).\nDefault shells on various operating systems:\nWindows: Powershell\nmacOS: Z shell (zsh)\nLinux: (usually) Bourne-again shell (bash)",
    "crumbs": [
      "Command Line",
      "Terminology"
    ]
  },
  {
    "objectID": "terminology.html#windows-using-windows-subsystem-for-linux-wsl",
    "href": "terminology.html#windows-using-windows-subsystem-for-linux-wsl",
    "title": "6  Terminology",
    "section": "",
    "text": "Open the Windows Terminal application\nRun (i.e. type in) wsl --install (and click enter)\nRestart your device\nOpen Windows Terminal\nRun wsl\nBy default this should open the distribution (Ubuntu by default)\n\n\nIf this doesn’t work, you may need to run wsl.exe --install -d Ubuntu and may need to restart your computer again\nEnter a username and password (does not need to match your computer login)\n\nYou won’t see what you type in appear on the screen, just hit enter when you are done\n\nTo log out of the distribution, run exit\nEvery time you open Windows Terminal, you need to run wsl to turn on Windows Subsystem for Linux",
    "crumbs": [
      "Command Line",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Terminology</span>"
    ]
  },
  {
    "objectID": "terminology.html#mac-using-terminal",
    "href": "terminology.html#mac-using-terminal",
    "title": "6  Terminology",
    "section": "6.2 Mac (using Terminal)",
    "text": "6.2 Mac (using Terminal)\n\nOpen Terminal (Applications &gt; Utilities &gt; Terminal)",
    "crumbs": [
      "Command Line",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Terminology</span>"
    ]
  },
  {
    "objectID": "command_line.html",
    "href": "command_line.html",
    "title": "Command Line",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Command Line"
    ]
  },
  {
    "objectID": "Command_Line_Tips.html",
    "href": "Command_Line_Tips.html",
    "title": "Command Line Tips",
    "section": "",
    "text": "Press ‘tab’ button to autofill\nDepending on shell, hitting tab once (zsh) or twice (bash) will display options if multiple exist\nPress ‘up’ arrow to recall last command\n‘Control + A’ to move to beginning of line\n‘Control + E’ to move to end of line\n‘Control + C’ to end (i.e. kill) command\n‘Control + Z’ to exit manual\nAvoid using spaces when naming files or folders\nBeware curly (i.e. smart) quotes ‘, be sure to use straight quotes '. Curly quotes usually come from text editors like Microsoft Word and don’t work when coding. To ensure you are using straight quotes, write code in a plain-text editor like TextEdit (Mac) or Notepad (Windows) and turn off spelling and grammar checking.",
    "crumbs": [
      "Command Line",
      "Command Line Tips"
    ]
  },
  {
    "objectID": "Scripting_Tips.html",
    "href": "Scripting_Tips.html",
    "title": "Scripting Tips",
    "section": "",
    "text": "When using a bash shell, start every script with #!/bin/bash\nWrite scripts with a plain-text editor such as TextEdit (Mac) or Notepad (Windows)\nTurn off spelling and grammar checking:\n\nIn TextEdit (Mac): Edit &gt; Spelling and Grammar &gt; Uncheck ‘Check Spelling While Typing’ and ‘Correct Spelling Automatically’\nIn Notepad (Windows): Select Setting (top right) &gt; Scroll down to Spelling section &gt; Toggle off ‘Autocorrect’ and ‘Spell Check’\n\nThoroughly annotate scripts (adding a # at the beginning of a line causes it to be ignored when the computer reads the script).",
    "crumbs": [
      "Command Line",
      "Scripting Tips"
    ]
  },
  {
    "objectID": "Built-In_Commands.html",
    "href": "Built-In_Commands.html",
    "title": "Built-In Command Line Tools",
    "section": "",
    "text": "Your terminal will have several commands already built into the command line. Below are a few of them with examples of how they are used.\npwd: print working directory (where am I currently?)\n \n/: root directory (folder that holds all other folders)\n./: current directory (current folder)\n../: parent directory (folder containing your current folder)\n \nls: list directory contents (list everything in current folder) (usage)\n\nFlags:\n\n-l: long format (permissions, sizes, dates, etc.)\n-F: indicate item types\n\ntrailing / = directory\n@ = link\n* = executable\n\n-r: reverse order (reverse alphabetic order)\n\n\n \nmkdir: make directory (i.e. folder) (usage)\n \nmv: move object (usage)\n\nmv [source(s)] [destination]\n*Warning* Will overwrite object if name already exists\nWhen in the same folder: renames object\nFlags:\n\n-i: interactive (ask for confirmation before overwriting)\n\n\n \ncp: copy object (usage)\n\ncp [source object(s)] [destination]\n*Warning* Will overwrite object if name already exists\nFlags:\n\n-R: copy directory (i.e. folder)\n-i: interactive (ask for confirmation before overwriting)\n\n\n \nhead: display the beginning (i.e. top) of a file (usage)\n\nFlags:\n\n-1: display first row\n-3: display first 3 rows\n\n\n \ntail: display the end (i.e. bottom) of a file (usage)\n\nFlags:\n\n-1: display last row\n-3: display last 3 rows\n\n\n \n| (shift + backslash): pipe (use outputs from one command as inputs for another)\n\nExample: display the 10th row of a file\n\nhead -10 path/to/file | tail -1\n\n\n \nwc: word count (lines, words, characters) (usage)\n\nFlags:\n\n-l: lines\n-w: words\n-c: characters",
    "crumbs": [
      "Command Line",
      "Built-In Command Line Tools"
    ]
  },
  {
    "objectID": "awk.html",
    "href": "awk.html",
    "title": "awk",
    "section": "",
    "text": "awk is scripting language named after its developers (Aho, Weinberger, and Kernighan) (usage)\n\nThings to know about awk:\n\nawk refers to columns as field, such as in the variables for number of fields (NF), input field separator (FS), and output field separator (OFS).\nawk refers to rows as records, such as in the variables for record number (NR), input record separator (RS), and output record separator (ORS).\nBy default, awk recognizes a space or tab as a field separator. If your input file has field separators other than a space or a tab, you need to specify it using the -F flag.\nawk has several built-in variables that can be used when writing code:\n\n$1 = field 1 ($2 = field 2, $3 = field 3, …)\n$0 = entire record\nNF = number of fields\nNR = number of records\nFS = input field separator; default is white space (i.e. space and tab)\nOFS = output field separator; default is single space\nRS = input record separator; default is new line\nORS = output record separator; default is new line\n[0-9] = any number\n\n\n\nBelow are examples of how the awk command can be used to achieve lots of desired outcomes when processing data files.\n\ncat data.txt # View data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nPrinting all of the fields (synonymous with awk '{print $0}' data.txt)\n\nawk '{print}' data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nPrint a particular field (e.g. field 1)\n\nawk '{print $1}' data.txt\n\nGenes\nGeneX\nGeneY\nGeneZ\n\n\nIf input file uses a comma (,) as a field separator instead of space or tab, set input field separator as (,) (synonymous with awk '{ FS = \",\" } ; {print $1}' data.csv).\n\nTry leaving out the -F, and see what happens.\n\n\ncat data.csv # View comma separated file (.csv)\n\nGenes,Sample1,Sample2,Sample3\nGeneX,3210,5678,689\nGeneY,2354,6700,987\nGeneZ,2315,7890,123\n\n\n\nawk -F, '{print $1}' data.csv\n\nGenes\nGeneX\nGeneY\nGeneZ\n\n\nPrint multiple fields (e.g. field 1 and 3)\n\nawk '{print $1,$3}' data.txt\n\nGenes Sample2\nGeneX 5678\nGeneY 6700\nGeneZ 7890\n\n\nPrint the last field\n\nawk '{print $NF}' data.txt\n\nSample3\n689\n987\n123\n\n\nPrint all records after the first record (synonymous with awk 'NR!=1 {print}' /path/to/file)\n\nawk 'NR&gt;1 {print}' data.txt\n\nGeneX   3210    5678    689\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nPrint a particular record (e.g. record 3)\n\nawk 'NR==3 {print}' data.txt\n\nGeneY   2354    6700    987\n\n\nPrint all records except for a particular record (e.g. not record 3)\n\nawk 'NR!=3 {print}' data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneZ   2315    7890    123\n\n\nPrint a range of records (e.g. records 2 to 3)\n\nawk 'NR==2, NR==3 {print}' data.txt\n\nGeneX   3210    5678    689\nGeneY   2354    6700    987\n\n\nPrint records with fewer than a certain number of fields (e.g. fewer than 4 fields)\n\ncat data2.txt # View data2.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    \nGeneZ   2315    7890    123\n\n\n\nawk 'NF&lt;4 {print}' data2.txt\n\nGeneY   2354    6700    \n\n\nPrint records containing a certain string anywhere in record (e.g. abc)\n\ncat data3.txt\n\nabcd    dcba    efgh    aabc\nbcde    dabc    cbad    abdc\ncdef    defg    efgh    fghi\n\n\n\nawk '/abc/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\nbcde    dabc    cbad    abdc\n\n\nPrint records starting with a certain string (e.g. abc)\n\nawk '/^abc/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\n\n\nPrint records ending with a certain string (e.g. abc) &gt;One caveat between macOS and Windows (even when using wsl) is that the line ending character in macOS (i.e. unix) is \\n while the line ending character in Windows is \\r\\n. This means that a text file made on a Mac may have a different line ending character than Windows recognizes (and vice versa). To avoid this problem…\n\nawk '/abc$/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\n\n\nPrint records that don’t contain a certain string anywhere in record (e.g. abc)\n\nawk '!/abc/ {print}' data3.txt\n\ncdef    defg    efgh    fghi\n\n\nPrint records that don’t start with a certain string (e.g. abc)\n\nawk '!/^abc/ {print}' data3.txt\n\nbcde    dabc    cbad    abdc\ncdef    defg    efgh    fghi\n\n\nPrint records that don’t end with a certain string (e.g. abc)\n\nawk '!/abc$/ {print}' data3.txt\n\nbcde    dabc    cbad    abdc\ncdef    defg    efgh    fghi\n\n\nPrint records where a particular field contains a string (e.g. abc in field 1)\n\nawk '$1 ~ /abc/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\n\n\nPrint records where a particular field starts with a string (e.g. abc in field 1)\n\nawk '$1 ~ /^abc/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\n\n\nPrint records where a particular field ends with a string (e.g. abc in field 4)\n\nawk '$4 ~ /abc$/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\n\n\nPrint records where a particular field starts with any number (e.g. field 1)\n\ncat data4.txt\n\n1ABC    D1CB    EF1G    AAB1\nb2cd    da2b    cba2    2abc\nCD3E    DEF3    3EFG    F2GH\n\n\n\nawk '$1 ~ /^[0-9]/ {print}' data4.txt\n\n1ABC    D1CB    EF1G    AAB1\n\n\nPrint records where a particular field ends with any number (e.g. field 1)\n\nawk '$1 ~ /[0-9]$/ {print}' data4.txt\n\nIgnore case when looking for records containing a string (e.g. abc)\n\nawk 'tolower($0) ~ /abc/ {print}' data4.txt\n\n1ABC    D1CB    EF1G    AAB1\nb2cd    da2b    cba2    2abc\n\n\nPrint records that contain a certain value in a particular field (e.g. the number 3210 in field 2)\n\ncat data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\n\nawk '$2==3210 {print}' data.txt\n\nGeneX   3210    5678    689\n\n\nPrint records that do not contain a certain value in a particular field (e.g. not the number 10 in field 2)\n\nawk '$2!=3210 {print}' data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nPrint records that contain a value greater than a certain value in a particular field (e.g. &gt;2354 in field 2)\n\nawk '$2&gt;2354 {print}' data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\n\n\nPrint records that contain a value less than a certain value in a particular field (e.g. &lt;2354 in field 2)\n\nawk '$2&lt;2354 {print}' data.txt\n\nGeneZ   2315    7890    123\n\n\nPrint records that contain a value less than or equal to a certain value in a particular field (e.g. &lt;2354 in field 2)\n\nawk '$2&lt;=2354 {print}' data.txt\n\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nSum values in a field (e.g. field 2)\n\nawk '{sum+=$2;} END{print sum;}' data.txt\n\n7879\n\n\nRemember to add NR&gt;1 if your file has a header in case the headers are numeric\n\nawk 'NR&gt;1 {sum+=$2;} END{print sum;}' data.txt\n\n7879\n\n\nRemove blank lines\n\ncat data5.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    987\n\nGeneZ   2315    7890    123\n\n\n\nawk 'NF' data5.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nPrint the record number at beginning of record\n\nawk '{print NR,$0}' data.txt\n\n1 Genes Sample1 Sample2 Sample3\n2 GeneX 3210    5678    689\n3 GeneY 2354    6700    987\n4 GeneZ 2315    7890    123",
    "crumbs": [
      "Command Line",
      "awk"
    ]
  },
  {
    "objectID": "R_basics.html",
    "href": "R_basics.html",
    "title": "Data Types",
    "section": "",
    "text": "R stores the data you give it in the most optimal way that it can for it to do the manipulations and graphing that you desire. Here are the terms we use to describe these classifications:\n\n\n\nTerm\nDefinition\n\n\n\n\nType\nClassification for how an object is stored internally in R (a.k.a. storage mode)\n\n\nClass\nBroader classification of how an object is stored in R (the more common language you would use in conversation and writing)\n\n\n\n\nThe term “object” describes any “thing” in R such as numbers, characters, etc. (described below).\n\nYou can figure out the type or class of any object by using the typeof() or class() functions, respectively. Here is how we determine the type and class of the object 3:\n\ntypeof(3)\n\n[1] \"double\"\n\nclass(3)\n\n[1] \"numeric\"\n\n\n\nThese operations are called functions. A function is some task you want R to perform and what you put inside the parentheses is the object you want R to perform that function on. In these examples, the “task” you want R to perform is to tell you what the type or class of of an object is and the object in these examples is 3.\n\n\nEvery function in R has specific requirements for how it is used. To learn about the requirements for any particular function you can use the help() function. For example, to learn how to use the typeof() function, you can run help(typeof).\n\nIn the examples above you’ll notice that typeof() and class() use different terms to describe the same object (in this case, 3). Below is a table that helps visualize these distinctions (there are many other types and classes but these are the ones you will see most often).\n\n\n\n\n\n\n\n\n\nObject\nType\nClass\nNotes\n\n\n\n\n“a”\nCharacter\nCharacter\nLetters must be in quotes or they will be interpreted as an object (discussed below)\n\n\n3\nDouble\nNumeric\nDouble = double precision floating point numbers (significand and exponent)\n\n\n3L\nInteger\nInteger\nCan only be whole numbers (i.e. no decimals)\n\n\nTRUE or FALSE\nLogical\nLogical\n\n\n\n\n In addition to determining the type or class of an object (using typeof() or class()), you can also determine if an object is a particular type or class (using is.double(), is.numeric(), is.integer(), is.character(), is.logical()). For example:\n\nis.double(3) # TRUE\nis.numeric(3) # TRUE\nis.integer(3) # FALSE\nis.character(3) # FALSE\n\nis.double(3L) # FALSE\nis.numeric(3L) # TRUE\nis.integer(3L) # TRUE\nis.character(3L) # FALSE\n\nis.logical(TRUE) # TRUE\nis.numeric(TRUE) # FALSE\nis.character(TRUE) # FALSE\nis.character(\"TRUE\") # TRUE\n\nis.logical(\"abc\") # FALSE\nis.numeric(\"abc\") # FALSE\nis.character(\"abc\") # TRUE\n\nNotice that the “answer” to these functions is logical (TRUE or FALSE); this is a very useful feature of R that you will see later.\n\nImagine having a data set with a list of cities and their average yearly rainfall totals. With a simple line of code, R can quickly tell you whether each city’s average yearly rainfall is above or below a certain number (outputing TRUE or FALSE for each city).\n\nIt is often useful to store some information (numbers, text, etc.) as a variable that can be easily referenced later. For example, rather than having to type out the number 10481034582 every time you need to use it, you can simply save it as a variable (R calls these variables “objects”). Let’s use the letter x as our new object:\n\n# After executing this function you should see it appear in your R environment under \"Values\" in the top-right corner of RStudio\n\nx &lt;- 10481034582\nx\n\n[1] 10481034582\n\n\nYou can change the value of your object by running the same code with a different value:\n\nx &lt;- 54321\nx\n\n[1] 54321\n\n\n\nCAUTION: this overwriting of an object can’t be undone except by starting over and regenerating it the way you did originally. To see if you have used an object name already, check under “Values” in the Environment panel in the top-right of RStudio.\n\nNow, anytime you need to use that value you can simply use the object instead:\n\ntypeof(12345)\n\n[1] \"double\"\n\nx &lt;- 12345\ntypeof(x)\n\n[1] \"double\"\n\n\n\n# Let's overwrite the object x to prove that it is holding the correct value\n\ntypeof(\"abcd\")\n\n[1] \"character\"\n\nx &lt;- \"abcd\"\ntypeof(x)\n\n[1] \"character\"\n\n\nThese new objects don’t have to be single letters, they can also be multiple letters or words; they just can’t start with a number or contain any special characters other than an underscore _. This can help you remember which objects are which:\n\nbig_number &lt;- 10481034582\nbig_number\n\n[1] 10481034582\n\nsmall_number &lt;- 54321\nsmall_number\n\n[1] 54321\n\n\nAs you start generating your own code and pipelines for analyzing data, you will find this feature particularly useful as you can avoid having to change every occurrence of an object and instead just change it a single time when you originally create the object.",
    "crumbs": [
      "Visualization",
      "Data Types"
    ]
  },
  {
    "objectID": "awk2.html",
    "href": "awk2.html",
    "title": "awk",
    "section": "",
    "text": "awk is scripting language named after its developers (Aho, Weinberger, and Kernighan) (usage)\n\nThings to know about awk:\n\nawk refers to columns as field, such as in the variables for number of fields (NF), input field separator (FS), and output field separator (OFS).\nawk refers to rows as records, such as in the variables for record number (NR), input record separator (RS), and output record separator (ORS).\nBy default, awk recognizes a space or tab as a field separator. If your input file has field separators other than a space or a tab, you need to specify it using the -F flag.\nawk has several built-in variables that can be used when writing code:\n\n$1 = field 1 ($2 = field 2, $3 = field 3, …)\n$0 = entire record\nNF = number of fields\nNR = number of records\nFS = input field separator; default is white space (i.e. space and tab)\nOFS = output field separator; default is single space\nRS = input record separator; default is new line\nORS = output record separator; default is new line\n[0-9] = any number\n\n\n\nBelow are examples of how the awk command can be used to achieve lots of desired outcomes when processing data files.\n\ncat data.txt # View data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nPrinting all of the fields (synonymous with awk '{print $0}' data.txt)\n\nawk '{print}' data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nPrint a particular field (e.g. field 1)\n\nawk '{print $1}' data.txt\n\nGenes\nGeneX\nGeneY\nGeneZ\n\n\nIf input file uses a comma (,) as a field separator instead of space or tab, set input field separator as (,) (synonymous with awk '{ FS = \",\" } ; {print $1}' data.csv).\n\nTry leaving out the -F, and see what happens.\n\n\ncat data.csv # View comma separated file (.csv)\n\nGenes,Sample1,Sample2,Sample3\nGeneX,3210,5678,689\nGeneY,2354,6700,987\nGeneZ,2315,7890,123\n\n\n\nawk -F, '{print $1}' data.csv\n\nGenes\nGeneX\nGeneY\nGeneZ\n\n\nPrint multiple fields (e.g. field 1 and 3)\n\nawk '{print $1,$3}' data.txt\n\nGenes Sample2\nGeneX 5678\nGeneY 6700\nGeneZ 7890\n\n\nPrint the last field\n\nawk '{print $NF}' data.txt\n\nSample3\n689\n987\n123\n\n\nPrint all records after the first record (synonymous with awk 'NR!=1 {print}' /path/to/file)\n\nawk 'NR&gt;1 {print}' data.txt\n\nGeneX   3210    5678    689\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nPrint a particular record (e.g. record 3)\n\nawk 'NR==3 {print}' data.txt\n\nGeneY   2354    6700    987\n\n\nPrint all records except for a particular record (e.g. not record 3)\n\nawk 'NR!=3 {print}' data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneZ   2315    7890    123\n\n\nPrint a range of records (e.g. records 2 to 3)\n\nawk 'NR==2, NR==3 {print}' data.txt\n\nGeneX   3210    5678    689\nGeneY   2354    6700    987\n\n\nPrint records with fewer than a certain number of fields (e.g. fewer than 4 fields)\n\ncat data2.txt # View data2.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    \nGeneZ   2315    7890    123\n\n\n\nawk 'NF&lt;4 {print}' data2.txt\n\nGeneY   2354    6700    \n\n\nPrint records containing a certain string anywhere in record (e.g. abc)\n\ncat data3.txt\n\nabcd    dcba    efgh    aabc\nbcde    dabc    cbad    abdc\ncdef    defg    efgh    fghi\n\n\n\nawk '/abc/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\nbcde    dabc    cbad    abdc\n\n\nPrint records starting with a certain string (e.g. abc)\n\nawk '/^abc/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\n\n\nPrint records ending with a certain string (e.g. abc) &gt;One caveat between macOS and Windows (even when using wsl) is that the line ending character in macOS (i.e. unix) is \\n while the line ending character in Windows is \\r\\n. This means that a text file made on a Mac may have a different line ending character than Windows recognizes (and vice versa). To avoid this problem…\n\nawk '/abc$/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\n\n\nPrint records that don’t contain a certain string anywhere in record (e.g. abc)\n\nawk '!/abc/ {print}' data3.txt\n\ncdef    defg    efgh    fghi\n\n\nPrint records that don’t start with a certain string (e.g. abc)\n\nawk '!/^abc/ {print}' data3.txt\n\nbcde    dabc    cbad    abdc\ncdef    defg    efgh    fghi\n\n\nPrint records that don’t end with a certain string (e.g. abc)\n\nawk '!/abc$/ {print}' data3.txt\n\nbcde    dabc    cbad    abdc\ncdef    defg    efgh    fghi\n\n\nPrint records where a particular field contains a string (e.g. abc in field 1)\n\nawk '$1 ~ /abc/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\n\n\nPrint records where a particular field starts with a string (e.g. abc in field 1)\n\nawk '$1 ~ /^abc/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\n\n\nPrint records where a particular field ends with a string (e.g. abc in field 4)\n\nawk '$4 ~ /abc$/ {print}' data3.txt\n\nabcd    dcba    efgh    aabc\n\n\nPrint records where a particular field starts with any number (e.g. field 1)\n\ncat data4.txt\n\n1ABC    D1CB    EF1G    AAB1\nb2cd    da2b    cba2    2abc\nCD3E    DEF3    3EFG    F2GH\n\n\n\nawk '$1 ~ /^[0-9]/ {print}' data4.txt\n\n1ABC    D1CB    EF1G    AAB1\n\n\nPrint records where a particular field ends with any number (e.g. field 1)\n\nawk '$1 ~ /[0-9]$/ {print}' data4.txt\n\nIgnore case when looking for records containing a string (e.g. abc)\n\nawk 'tolower($0) ~ /abc/ {print}' data4.txt\n\n1ABC    D1CB    EF1G    AAB1\nb2cd    da2b    cba2    2abc\n\n\nPrint records that contain a certain value in a particular field (e.g. the number 3210 in field 2)\n\ncat data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\n\nawk '$2==3210 {print}' data.txt\n\nGeneX   3210    5678    689\n\n\nPrint records that do not contain a certain value in a particular field (e.g. not the number 10 in field 2)\n\nawk '$2!=3210 {print}' data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nPrint records that contain a value greater than a certain value in a particular field (e.g. &gt;2354 in field 2)\n\nawk '$2&gt;2354 {print}' data.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\n\n\nPrint records that contain a value less than a certain value in a particular field (e.g. &lt;2354 in field 2)\n\nawk '$2&lt;2354 {print}' data.txt\n\nGeneZ   2315    7890    123\n\n\nPrint records that contain a value less than or equal to a certain value in a particular field (e.g. &lt;2354 in field 2)\n\nawk '$2&lt;=2354 {print}' data.txt\n\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nSum values in a field (e.g. field 2)\n\nawk '{sum+=$2;} END{print sum;}' data.txt\n\n7879\n\n\nRemember to add NR&gt;1 if your file has a header in case the headers are numeric\n\nawk 'NR&gt;1 {sum+=$2;} END{print sum;}' data.txt\n\n7879\n\n\nRemove blank lines\n\ncat data5.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    987\n\nGeneZ   2315    7890    123\n\n\n\nawk 'NF' data5.txt\n\nGenes   Sample1 Sample2 Sample3\nGeneX   3210    5678    689\nGeneY   2354    6700    987\nGeneZ   2315    7890    123\n\n\nPrint the record number at beginning of record\n\nawk '{print NR,$0}' data.txt\n\n1 Genes Sample1 Sample2 Sample3\n2 GeneX 3210    5678    689\n3 GeneY 2354    6700    987\n4 GeneZ 2315    7890    123",
    "crumbs": [
      "R",
      "awk"
    ]
  },
  {
    "objectID": "R_basics2.html",
    "href": "R_basics2.html",
    "title": "R basics2",
    "section": "",
    "text": "This is test bash code\n\n# Test bash code\n\nThis is a test R code block\n\n# Test R code\ndim(cars)\n\n[1] 50  2",
    "crumbs": [
      "Visualization",
      "R basics2"
    ]
  },
  {
    "objectID": "R_Data_Types.html",
    "href": "R_Data_Types.html",
    "title": "Data Types",
    "section": "",
    "text": "R stores the data you give it in the most optimal way that it can for it to do the manipulations and graphing that you desire. Here are the terms we use to describe these classifications:\n\n\n\nTerm\nDefinition\n\n\n\n\nType\nClassification for how an object is stored internally in R (a.k.a. storage mode)\n\n\nClass\nBroader classification of how an object is stored in R (the more common language you would use in conversation and writing)\n\n\n\n\nThe term “object” describes any “thing” in R such as numbers, characters, etc. (described below).\n\nYou can figure out the type or class of any object by using the typeof() or class() functions, respectively. Here is how we determine the type and class of the object 3:\n\ntypeof(3)\n\n[1] \"double\"\n\nclass(3)\n\n[1] \"numeric\"\n\n\n\nThese operations are called functions. A function is some task you want R to perform and what you put inside the parentheses is the object you want R to perform that function on. In these examples, the “task” you want R to perform is to tell you what the type or class of of an object is and the object in these examples is 3.\n\n\nEvery function in R has specific requirements for how it is used. To learn about the requirements for any particular function you can use the help() function. For example, to learn how to use the typeof() function, you can run help(typeof).\n\nIn the examples above you’ll notice that typeof() and class() use different terms to describe the same object (in this case, 3). Below is a table that helps visualize these distinctions (there are many other types and classes but these are the ones you will see most often).\n\n\n\n\n\n\n\n\n\nObject\nType\nClass\nNotes\n\n\n\n\n“a”\nCharacter\nCharacter\nLetters must be in quotes or they will be interpreted as an object (discussed below)\n\n\n3\nDouble\nNumeric\nDouble = double precision floating point numbers (significand and exponent)\n\n\n3L\nInteger\nInteger\nCan only be whole numbers (i.e. no decimals)\n\n\nTRUE or FALSE\nLogical\nLogical\n\n\n\n\n In addition to determining the type or class of an object (using typeof() or class()), you can also determine if an object is a particular type or class (using is.double(), is.numeric(), is.integer(), is.character(), is.logical()). For example:\n\nis.double(3) # TRUE\nis.numeric(3) # TRUE\nis.integer(3) # FALSE\nis.character(3) # FALSE\n\nis.double(3L) # FALSE\nis.numeric(3L) # TRUE\nis.integer(3L) # TRUE\nis.character(3L) # FALSE\n\nis.logical(TRUE) # TRUE\nis.numeric(TRUE) # FALSE\nis.character(TRUE) # FALSE\nis.character(\"TRUE\") # TRUE\n\nis.logical(\"abc\") # FALSE\nis.numeric(\"abc\") # FALSE\nis.character(\"abc\") # TRUE\n\nNotice that the “answer” to these functions is logical (TRUE or FALSE); this is a very useful feature of R that you will see later.\n\nImagine having a data set with a list of cities and their average yearly rainfall totals. With a simple line of code, R can quickly tell you whether each city’s average yearly rainfall is above or below a certain number (outputing TRUE or FALSE for each city).\n\nIt is often useful to store some information (numbers, text, etc.) as a variable that can be easily referenced later. For example, rather than having to type out the number 10481034582 every time you need to use it, you can simply save it as a variable (R calls these variables “objects”). Let’s use the letter x as our new object. After executing this function you should see it appear in your R environment under “Values” in the Environment panel in the top-right corner of RStudio:\n\nx &lt;- 10481034582\nx\n\n[1] 10481034582\n\n\nYou can change the value of your object by running the same code with a different value:\n\nx &lt;- 54321\nx\n\n[1] 54321\n\n\n\nCAUTION: this overwriting of an object can’t be undone except by starting over and regenerating it the way you did originally. To see if you have used an object name already, check under “Values” in the Environment panel in the top-right of RStudio.\n\nNow, anytime you need to use that value you can simply use the object instead:\n\ntypeof(12345)\n\n[1] \"double\"\n\nx &lt;- 12345\ntypeof(x)\n\n[1] \"double\"\n\n\n\n# Let's overwrite the object x to prove that it is holding the correct value\n\ntypeof(\"abcd\")\n\n[1] \"character\"\n\nx &lt;- \"abcd\"\ntypeof(x)\n\n[1] \"character\"\n\n\nThese new objects don’t have to be single letters, they can also be multiple letters or words; they just can’t start with a number or contain any special characters other than an underscore _. This can help you remember which objects are which:\n\nbig_number &lt;- 10481034582\nbig_number\n\n[1] 10481034582\n\nsmall_number &lt;- 54321\nsmall_number\n\n[1] 54321\n\n\nAs you start generating your own code and pipelines for analyzing data, you will find this feature particularly useful as you can avoid having to change every occurrence of an object and instead just change it a single time when you originally create the object.",
    "crumbs": [
      "R",
      "Data Types"
    ]
  },
  {
    "objectID": "R_Data_Structures.html",
    "href": "R_Data_Structures.html",
    "title": "Data Structures",
    "section": "",
    "text": "In the previous section we discussed storing objects as variables so that they can be easily referenced later:\n\nx &lt;- 54321 # Store the number 54321 as a object called 'x'\nx # View the contents of x\n\n[1] 54321\n\ntypeof(x) # Check the data type of x\n\n[1] \"double\"\n\ny &lt;- \"science\" # Store the word \"science\" as a object called 'y'\ny # View the contents of y\n\n[1] \"science\"\n\ntypeof(y) # Check the data type of y\n\n[1] \"character\"\n\n\nR can handle much more than a single object in a variable. You can add thousands of objects to a single variable and they can be of the same or different types and even have multiple rows or columns. The terms used to describe how multiple objects are stored depends on whether the objects are of the same (homogeneous) or different (heterogeneous) types and their dimensions:\n\n\n\nRows\nHomogeneous\nHeterogeneous\n\n\n\n\n1d\nAtomic vector\nList\n\n\n2d\nMatrix\nData frame\n\n\nnd\nArray\n\n\n\n\nIn the simplest case, a group of objects of the same type can be combined (using combine, c()) to form an atomic vector:\n\nstring &lt;- c(1,2,3,4,5) # Create an object called 'string' containing the numbers 1-5\nstring # View the contents of string\n\n[1] 1 2 3 4 5\n\ntypeof(string) # Check the data type of string\n\n[1] \"double\"\n\nis.atomic(string) # Check if string is an atomic vector\n\n[1] TRUE\n\n\nHowever, if you try to combine objects of different types using c(), R will force (i.e. coerce) them all to the same data type (in this case, characters):\n\nstring &lt;- c(1,2,3,4,5,\"six\") # Create an object called 'string' containing the numbers 1-5 and the word \"six\"\nstring # View the contents of string\n\n[1] \"1\"   \"2\"   \"3\"   \"4\"   \"5\"   \"six\"\n\ntypeof(string) # Check the data type of string\n\n[1] \"character\"\n\nis.atomic(string) # Check if string is an atomic vector\n\n[1] TRUE\n\n\nTo ensure that the original data type is preserved, you can instead use a list:\n\nstring &lt;- list(1,2,3,4,5,\"six\") # Create an object called 'string' containing the numbers 1-5 and the word \"six\". stored as a list\ntypeof(string) # Check the data type of string\n\n[1] \"list\"\n\nis.atomic(string) # Check if string is an atomic vector\n\n[1] FALSE\n\n\nYou can even confirm that the data type of each element in the list has been preserved (this code uses a process called subsetting, a topic that will be discussed later):\n\n# Determine the data type of the 2nd element in the list\ntypeof(string[[2]]) \n\n[1] \"double\"\n\n# Determine the data type of the 6th element in the list\ntypeof(string[[6]])\n\n[1] \"character\"\n\n\nWhile atomic vectors and lists are one-dimensional data structures, data can also be stored in multiple dimensions. A two-dimensional structure that contains data of the same type is called a matrix. There are multiple ways to create a matrix. One of them is by using a column bind (cbind()) or row bind (rbind()):\n\nmatrix_A &lt;- cbind(c(1,2,3),c(4,5,6)) # Create a matrix using cbind and store it as an object called 'matrix_A'\nmatrix_A # View the contents of matrix_A\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\ntypeof(matrix_A) # Check the data type of matrix_A\n\n[1] \"double\"\n\nis.matrix(matrix_A) # Check if matrix_A is a matrix\n\n[1] TRUE\n\n\n\nmatrix_B &lt;- rbind(c(1,2,3),c(4,5,6)) # Create a matrix using rbind and store it as an object called 'matrix_B'\nmatrix_B # View the contents of matrix_B\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\ntypeof(matrix_B) # Check the data type of matrix_B\n\n[1] \"double\"\n\nis.matrix(matrix_B) # Check if matrix_B is a matrix\n\n[1] TRUE\n\n\nAs with using c() above to create a vector, R will coerce everything to the same data type:\n\nmatrix_C &lt;- rbind(c(1,2,\"three\"),c(4,5,6)) # Create a matrix using rbind and store it as an object called 'matrix_C'\nmatrix_C # View the contents of matrix_C\n\n     [,1] [,2] [,3]   \n[1,] \"1\"  \"2\"  \"three\"\n[2,] \"4\"  \"5\"  \"6\"    \n\ntypeof(matrix_C) # Check the data type of matrix_C\n\n[1] \"character\"\n\n\nEven if you try to make one row of the matrix a list to preserve the different data types, R will coerce every row of the matrix to a list so that it is technically still the same data type throughout:\n\nmatrix_C &lt;- rbind(list(1,2,\"three\"),c(4,5,6)) # Create a matrix using rbind and store it as an object called 'matrix_C'\nmatrix_C # View the contents of matrix_C\n\n     [,1] [,2] [,3]   \n[1,] 1    2    \"three\"\n[2,] 4    5    6      \n\ntypeof(matrix_C) # Check the data type of matrix_C\n\n[1] \"list\"\n\nis.matrix(matrix_C) # Check if matrix_C is a matrix\n\n[1] TRUE\n\ntypeof(matrix_C[2,]) # Check the type of data stored in row 2 of matrix_C\n\n[1] \"list\"\n\n\nSo while this technically does allow the matrix to hold different data types, storing them within lists prevents certain matrix operations from being able to be used on the matrix.\nTo preserve different data types in a two-dimensional structure without needing to store them as lists, you can instead use a data frame. This will allow atomic vectors of different types to be combined as columns within a single structure:\n\ndataframe_A &lt;- data.frame(c(1,2,3),c(\"four\", \"five\", \"six\")) # Create a data frame and store it as an object called dataframe_A\ndataframe_A # View dataframe_A\n\n  c.1..2..3. c..four....five....six..\n1          1                     four\n2          2                     five\n3          3                      six\n\ntypeof(dataframe_A[,1]) # Check type of data in column 1 of dataframe_A\n\n[1] \"double\"\n\ntypeof(dataframe_A[,2]) # Check type of data in column 2 of dataframe_A\n\n[1] \"character\"\n\nis.data.frame(dataframe_A) # Check if dataframe_A is a data frame?\n\n[1] TRUE\n\n\nFinally, a data structure with two or more dimensions is called an array. Arrays are similar to matrices in that they can only store one data type (unless you store the data as lists as described above for matrices, which limits which array functions can be used):\n\narray_A &lt;- array(1:12, dim = c(2, 3, 2)) # Create an array using the numbers 1-12 stored in 2 rows, 3 columns, and 2 \"layers\" (i.e. the third dimension) and store it as an object called array_A\narray_A # View the contents of array_A\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n\nThe most common data structure used in bioinformatics is a data frame, though you may also use matrices for simpler datasets. Knowing how each data structure is composed and what data type(s) can be stored within them will be very useful when trying to perform operations on these structures (as will be discussed later).",
    "crumbs": [
      "R",
      "Data Structures"
    ]
  },
  {
    "objectID": "R_Install.html",
    "href": "R_Install.html",
    "title": "Installing R and RStudio",
    "section": "",
    "text": "R is a free software environment for statistical computing and graphics that is very popular for processing and visualizing biological data. RStudio integrated development environment (IDE) is a set of tools built to help you be more productive with R (and Python).\n\nDownloaded R: https://cran.rstudio.com/\nDownload RStudio Desktop: https://posit.co/download/rstudio-desktop/\n\nAlternatively, RStudio can be used online, however this version may have difficulty with more computationally-heavy processes.",
    "crumbs": [
      "R",
      "Installing R and RStudio"
    ]
  }
]